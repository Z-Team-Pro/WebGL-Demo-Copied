// Generated by CoffeeScript 1.3.3
var BounceModel, DepthRender, Illumination, LightmapShadowMap, Quad, Rendernode, Sphere, Texture2D, _ref;

Quad = require('/webgl/quad');

Sphere = require('/webgl/sphere');

Texture2D = require('/webgl/texture').Texture2D;

Rendernode = require('/rendernode');

_ref = require('/depth'), DepthRender = _ref.DepthRender, LightmapShadowMap = _ref.LightmapShadowMap;

BounceModel = require('bounce_model');

return Illumination = (function() {

  function Illumination(gl, sun, lighting, model, highresmodel, normaldepth, orientation, elevation, shconst) {
    var floatExt;
    this.gl = gl;
    this.lighting = lighting;
    this.shconst = shconst;
    this.proj = new Mat4().perspective(90, 1, 0.01, 42);
    this.view = new Mat4();
    this.mapsize = 32;
    this.probesize = 16;
    this.generateProbes();
    floatExt = this.gl.getFloatExtension({
      require: ['renderable', 'filterable']
    });
    this.debug = new Rendernode(this.gl, {
      program: get('debug.shader'),
      drawable: new Sphere(this.gl, 0.6),
      depthBuffer: true,
      depthTest: true,
      depthWrite: true,
      cullFace: 'BACK',
      type: floatExt.type
    });
    this.lightprobes = new Rendernode(this.gl, {
      width: this.probesize * 6,
      height: this.probesize * this.probes.length,
      program: get('transfer.shader'),
      drawable: quad,
      filter: 'nearest',
      type: floatExt.type
    });
    this.coefficients = new Rendernode(this.gl, {
      width: 9,
      height: this.probes.length,
      program: get('harmonics.shader'),
      drawable: quad,
      filter: 'nearest',
      type: floatExt.type
    });
    this.direct_light = new LightmapShadowMap(gl, {
      drawable: model,
      depthWidth: 128,
      depthHeight: 128,
      light: sun,
      blurred: true
    });
    this.bounce = new Rendernode(this.gl, {
      width: 256,
      height: 256,
      program: get('bounce.shader'),
      drawable: new BounceModel(this.gl, model, this.probes),
      type: floatExt.type,
      blend: 'additive'
    });
    this.renderProbes(model, highresmodel);
    this.update();
  }

  Illumination.prototype.generateProbes = function() {
    var i, _i, _j, _results;
    this.probes = [];
    for (i = _i = 0; _i < 7; i = ++_i) {
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: 0
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: 5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: -5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: 0
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: 5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: -5.5
      });
    }
    _results = [];
    for (i = _j = 1; _j < 6; i = ++_j) {
      _results.push(this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 12.5,
        z: 0
      }));
    }
    return _results;
  };

  Illumination.prototype.updateDirectLight = function() {
    return this.direct_light.update();
  };

  Illumination.prototype.update = function() {
    var i, _i, _ref1, _results;
    this.bounce.start().clear(0, 0, 0, 1).f('gi_gain', this.lighting.giGain).val2('coefficients_size', this.coefficients.width, this.coefficients.height).fv('shconst', this.shconst.data).end();
    this.lightprobes.start().vec3('sun_radiance', this.lighting.sun_radiance).vec3('sky_radiance', this.lighting.sky_radiance).sampler('texmap', this.texmap).sampler('diffusemap', this.diffusemap).sampler('bounce', this.bounce).sampler('lightmap', this.direct_light.output).draw().end();
    this.coefficients.start().val2('lightprobes_size', this.lightprobes.width, this.lightprobes.height).sampler('lightprobes', this.lightprobes).fv('shconst', this.shconst.data).draw().end();
    _results = [];
    for (i = _i = 0, _ref1 = this.lighting.bounces - 1; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      this.bounce.start().clear(0, 0, 0, 0).sampler('coefficients', this.coefficients).draw().end();
      this.lightprobes.start().sampler('texmap', this.texmap).sampler('bounce', this.bounce).sampler('lightmap', this.direct_light.output).draw().end();
      _results.push(this.coefficients.start().val2('lightprobes_size', this.lightprobes.width, this.lightprobes.height).sampler('lightprobes', this.lightprobes).draw().end());
    }
    return _results;
  };

  Illumination.prototype.renderProbes = function(model, highresmodel) {
    var i, probe, _i, _j, _len, _len1, _ref1, _ref2;
    if (get.exists('texmap.png')) {
      this.texmap = new Texture2D(this.gl).bind().upload(get('texmap.png')).nearest().clampToEdge().unbind();
    } else {
      this.texmap = new Rendernode(this.gl, {
        width: this.mapsize * 6,
        height: this.mapsize * this.probes.length,
        program: get('cubeprobe.shader'),
        drawable: model,
        depthTest: true,
        depthWrite: true,
        cullFace: 'BACK',
        filter: 'nearest',
        depthBuffer: true
      });
      this.texmap.start().clear(0, 0, 1);
      this.texmap.mat4('proj', this.proj);
      _ref1 = this.probes;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        probe = _ref1[i];
        this.renderProbe(i, this.texmap, null, probe.x, probe.y, probe.z);
      }
      this.texmap.end();
      this.texmap = this.texmap.output;
    }
    if (get.exists('diffusemap.jpg')) {
      return this.diffusemap = new Texture2D(this.gl).bind().upload(get('diffusemap.jpg')).nearest().clampToEdge().unbind();
    } else {
      this.diffusemap = new Rendernode(this.gl, {
        width: this.mapsize * 6,
        height: this.mapsize * this.probes.length,
        program: get('cube_diffuse.shader'),
        drawable: highresmodel,
        depthTest: true,
        depthWrite: true,
        cullFace: 'BACK',
        filter: 'nearest',
        depthBuffer: true
      });
      this.diffusemap.start().clear(0, 0, 0);
      this.diffusemap.mat4('proj', this.proj);
      _ref2 = this.probes;
      for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
        probe = _ref2[i];
        this.renderProbe(i, this.diffusemap, 'diffuse_texture', probe.x, probe.y, probe.z);
      }
      this.diffusemap.end();
      return this.diffusemap = this.diffusemap.output;
    }
  };

  Illumination.prototype.renderProbe = function(i, node, texture_type, x, y, z) {
    var offset, s;
    s = this.mapsize;
    offset = i * s;
    this.view.identity().translateVal3(-x, -y, -z);
    node.viewport(s * 0, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(180).translateVal3(-x, -y, -z);
    node.viewport(s * 1, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(-90).translateVal3(-x, -y, -z);
    node.viewport(s * 2, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(90).translateVal3(-x, -y, -z);
    node.viewport(s * 3, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatex(-90).translateVal3(-x, -y, -z);
    node.viewport(s * 4, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatex(90).translateVal3(-x, -y, -z);
    return node.viewport(s * 5, offset, s, s).mat4('view', this.view).drawModel(texture_type);
  };

  Illumination.prototype.drawDebug = function(camera, normaldepth) {
    var i, probe, _i, _len, _ref1;
    this.debug.start().clearBoth(0, 0, 0, 0).f('gi_gain', this.lighting.giGain).sampler('normaldepth', normaldepth).sampler('coefficients', this.coefficients).val2('coefficients_size', this.coefficients.width, this.coefficients.height).fv('shconst', this.shconst.data).mat4('proj', camera.proj).mat4('view', camera.view);
    _ref1 = this.probes;
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      probe = _ref1[i];
      this.debug.val3('offset', probe.x, probe.y, probe.z).f('index', i).draw();
    }
    return this.debug.end();
  };

  return Illumination;

})();
