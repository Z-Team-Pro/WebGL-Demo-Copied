// Generated by CoffeeScript 1.3.3
var LowresModel, Materials, Model, Texture2D,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Texture2D = require('/webgl/texture').Texture2D;

Materials = Materials = (function() {

  Materials.prototype.createTexture = function(path) {
    var image, texture;
    texture = this.texture_cache[path];
    if (!texture) {
      image = get(path);
      texture = new Texture2D(this.gl).bind().upload(image).mipmap().repeat().unbind();
      this.texture_cache[path] = texture;
    }
    return texture;
  };

  function Materials(gl) {
    var definition, diffuse, jpgbump, luma, pngbump, specular, _i, _len, _ref;
    this.gl = gl;
    this.texture_cache = {};
    this.definitions = get('materials.json');
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    _ref = this.definitions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      definition = _ref[_i];
      diffuse = "diffuse/" + definition.diffuse_texture;
      jpgbump = "bump/" + definition.bumpmap;
      pngbump = jpgbump.replace('.jpg', '.png');
      definition.diffuse_texture = this.createTexture(diffuse);
      specular = definition.specular_color;
      luma = (specular.r + specular.g + specular.b) / 3;
      definition.specularity = luma * definition.specularity;
      if (get.exists(pngbump)) {
        definition.bumpmap = this.createTexture(pngbump);
      } else if (get.exists(jpgbump)) {
        definition.bumpmap = this.createTexture(jpgbump);
      } else {
        definition.bumpmap = definition.diffuse_texture;
      }
    }
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.diffuse_texture = this.sortById('diffuse_texture');
    this.bumpmap = this.sortById('bumpmap');
  }

  Materials.prototype.sortById = function(type) {
    var definition, result;
    result = (function() {
      var _i, _len, _ref, _results;
      _ref = this.definitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        definition = _ref[_i];
        _results.push(definition);
      }
      return _results;
    }).call(this);
    result.sort(function(a, b) {
      return a[type].id - b[type].id;
    });
    return result;
  };

  return Materials;

})();

exports.LowresModel = LowresModel = (function(_super) {

  __extends(LowresModel, _super);

  LowresModel.prototype.attribs = ['position', 'texcoord', 'normal'];

  LowresModel.prototype.pointers = [
    {
      name: 'position',
      size: 3,
      offset: 0,
      stride: 8
    }, {
      name: 'texcoord',
      size: 2,
      offset: 3,
      stride: 8
    }, {
      name: 'normal',
      size: 3,
      offset: 5,
      stride: 8
    }
  ];

  function LowresModel(gl) {
    this.gl = gl;
    LowresModel.__super__.constructor.call(this);
    this.vertices = new Float32Array(get('lowres.vertices'));
    this.size = this.vertices.length / 8;
    this.upload(this.vertices);
  }

  return LowresModel;

})(require('/webgl/drawable'));

exports.Model = Model = (function(_super) {

  __extends(Model, _super);

  Model.prototype.attribs = ['position', 'texcoord', 'normal'];

  Model.prototype.pointers = [
    {
      name: 'position',
      size: 3,
      offset: 0,
      stride: 8
    }, {
      name: 'texcoord',
      size: 2,
      offset: 3,
      stride: 8
    }, {
      name: 'normal',
      size: 3,
      offset: 5,
      stride: 8
    }
  ];

  function Model(gl) {
    var buffer, indices, vertices;
    this.gl = gl;
    Model.__super__.constructor.call(this);
    this.materials = new Materials(this.gl);
    indices = new Uint16Array(get('sponza.indices'));
    vertices = new Float32Array(get('sponza.vertices'));
    this.size = indices.length;
    this.max_angle = Math.cos(Math.PI * 2 * (43 / 360));
    this.computeVertexFaces(indices, vertices);
    this.computeFaceNormals(indices, vertices);
    buffer = this.calculateVertices(indices, vertices);
    this.upload(buffer);
  }

  Model.prototype.computeVertexFaces = function(indices, vertices) {
    var c1, c2, c3, count, counts, end, face_count, face_index, idx1, idx2, idx3, index, iv, max, start, vertex_count, vertex_faces, _i, _j, _k, _len, _len1;
    start = gettime();
    vertex_count = vertices.length / 5;
    counts = new Uint8Array(vertex_count);
    for (_i = 0, _len = indices.length; _i < _len; _i++) {
      index = indices[_i];
      counts[index] += 1;
    }
    max = 0;
    for (_j = 0, _len1 = counts.length; _j < _len1; _j++) {
      count = counts[_j];
      if (count > max) {
        max = count;
      }
    }
    this.max_count = max;
    vertex_faces = new Uint32Array(max * vertex_count);
    counts = new Uint8Array(vertex_count);
    face_count = indices.length / 3;
    for (face_index = _k = 0; 0 <= face_count ? _k < face_count : _k > face_count; face_index = 0 <= face_count ? ++_k : --_k) {
      iv = face_index * 3;
      idx1 = indices[iv];
      idx2 = indices[iv + 1];
      idx3 = indices[iv + 2];
      c1 = counts[idx1]++;
      c2 = counts[idx2]++;
      c3 = counts[idx3]++;
      vertex_faces[idx1 * max + c1] = face_index;
      vertex_faces[idx2 * max + c2] = face_index;
      vertex_faces[idx3 * max + c3] = face_index;
    }
    end = gettime();
    this.vertex_face_count = counts;
    return this.vertex_faces = vertex_faces;
  };

  Model.prototype.computeFaceNormals = function(indices, vertices) {
    var btx, bty, btz, end, face_count, i, i1, i2, i3, iv, l, normals, nx, ny, nz, start, tx, ty, tz, x1, x2, x3, y1, y2, y3, z1, z2, z3, _i;
    start = gettime();
    face_count = indices.length / 3;
    normals = new Float32Array(face_count * 3);
    for (i = _i = 0; 0 <= face_count ? _i < face_count : _i > face_count; i = 0 <= face_count ? ++_i : --_i) {
      iv = i * 3;
      i1 = indices[iv];
      i2 = indices[iv + 1];
      i3 = indices[iv + 2];
      x1 = vertices[i1 * 5];
      y1 = vertices[i1 * 5 + 1];
      z1 = vertices[i1 * 5 + 2];
      x2 = vertices[i2 * 5];
      y2 = vertices[i2 * 5 + 1];
      z2 = vertices[i2 * 5 + 2];
      x3 = vertices[i3 * 5];
      y3 = vertices[i3 * 5 + 1];
      z3 = vertices[i3 * 5 + 2];
      tx = x2 - x1;
      ty = y2 - y1;
      tz = z2 - z1;
      btx = x3 - x1;
      bty = y3 - y1;
      btz = z3 - z1;
      nx = ty * btz - tz * bty;
      ny = tz * btx - tx * btz;
      nz = tx * bty - ty * btx;
      l = Math.sqrt(nx * nx + ny * ny + nz * nz);
      nx /= l;
      ny /= l;
      nz /= l;
      normals[iv + 0] = nx;
      normals[iv + 1] = ny;
      normals[iv + 2] = nz;
    }
    this.normals = normals;
    return end = gettime();
  };

  Model.prototype.getNormal = function(face_index, vertex_index) {
    var c, cos, l, nx, ny, nz, rx, ry, rz, vfidx, x, y, z, _i, _ref;
    rx = this.normals[face_index * 3 + 0];
    ry = this.normals[face_index * 3 + 1];
    rz = this.normals[face_index * 3 + 2];
    nx = 0;
    ny = 0;
    nz = 0;
    for (c = _i = 0, _ref = this.vertex_face_count[vertex_index]; 0 <= _ref ? _i < _ref : _i > _ref; c = 0 <= _ref ? ++_i : --_i) {
      vfidx = this.vertex_faces[vertex_index * this.max_count + c];
      x = this.normals[vfidx * 3 + 0];
      y = this.normals[vfidx * 3 + 1];
      z = this.normals[vfidx * 3 + 2];
      cos = rx * x + ry * y + rz * z;
      if (cos > this.max_angle) {
        nx = x;
        ny = y;
        nz = z;
      }
    }
    l = Math.sqrt(nx * nx + ny * ny + nz * nz);
    return [nx / l, ny / l, nz / l];
  };

  Model.prototype.calculateVertices = function(indices, vertices, normals) {
    var end, i, i1, i2, i3, iv, nx, ny, nz, result, start, u1, u2, u3, v1, v2, v3, x1, x2, x3, y1, y2, y3, z1, z2, z3, _i, _ref, _ref1, _ref2, _ref3;
    start = gettime();
    result = new Float32Array(indices.length * 8);
    for (i = _i = 0, _ref = indices.length / 3; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      iv = i * 3;
      i1 = indices[iv];
      i2 = indices[iv + 1];
      i3 = indices[iv + 2];
      x1 = vertices[i1 * 5];
      y1 = vertices[i1 * 5 + 1];
      z1 = vertices[i1 * 5 + 2];
      u1 = vertices[i1 * 5 + 3];
      v1 = vertices[i1 * 5 + 4];
      x2 = vertices[i2 * 5];
      y2 = vertices[i2 * 5 + 1];
      z2 = vertices[i2 * 5 + 2];
      u2 = vertices[i2 * 5 + 3];
      v2 = vertices[i2 * 5 + 4];
      x3 = vertices[i3 * 5];
      y3 = vertices[i3 * 5 + 1];
      z3 = vertices[i3 * 5 + 2];
      u3 = vertices[i3 * 5 + 3];
      v3 = vertices[i3 * 5 + 4];
      _ref1 = this.getNormal(i, i1), nx = _ref1[0], ny = _ref1[1], nz = _ref1[2];
      result[(iv + 0) * 8 + 0] = x1;
      result[(iv + 0) * 8 + 1] = y1;
      result[(iv + 0) * 8 + 2] = z1;
      result[(iv + 0) * 8 + 3] = u1;
      result[(iv + 0) * 8 + 4] = v1;
      result[(iv + 0) * 8 + 5] = nx;
      result[(iv + 0) * 8 + 6] = ny;
      result[(iv + 0) * 8 + 7] = nz;
      _ref2 = this.getNormal(i, i2), nx = _ref2[0], ny = _ref2[1], nz = _ref2[2];
      result[(iv + 1) * 8 + 0] = x2;
      result[(iv + 1) * 8 + 1] = y2;
      result[(iv + 1) * 8 + 2] = z2;
      result[(iv + 1) * 8 + 3] = u2;
      result[(iv + 1) * 8 + 4] = v2;
      result[(iv + 1) * 8 + 5] = nx;
      result[(iv + 1) * 8 + 6] = ny;
      result[(iv + 1) * 8 + 7] = nz;
      _ref3 = this.getNormal(i, i3), nx = _ref3[0], ny = _ref3[1], nz = _ref3[2];
      result[(iv + 2) * 8 + 0] = x3;
      result[(iv + 2) * 8 + 1] = y3;
      result[(iv + 2) * 8 + 2] = z3;
      result[(iv + 2) * 8 + 3] = u3;
      result[(iv + 2) * 8 + 4] = v3;
      result[(iv + 2) * 8 + 5] = nx;
      result[(iv + 2) * 8 + 6] = ny;
      result[(iv + 2) * 8 + 7] = nz;
    }
    end = gettime();
    return result;
  };

  'draw: (shader) ->\n    if shader then @setPointersForShader shader\n    for material in @materials\n        #@gl.drawArrays @mode, @first, @size\n        @gl.drawArrays @mode, material.start, material.size\n    if shader then @disableAttribs shader\n    return @';


  return Model;

})(require('/webgl/drawable'));
