// Generated by CoffeeScript 1.3.3
var Quad, Rendernode, Window, Windows, keys,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Quad = require('/webgl/quad');

Rendernode = require('/rendernode');

keys = require('/keys');

Window = (function() {

  function Window(index, texture, node, x, y) {
    this.index = index;
    this.texture = texture;
    this.node = node;
    this.x = x;
    this.y = y;
    this.label = this.texture.label;
    if (this.texture.diva) {
      this.diva = 1;
    } else {
      this.diva = 0;
    }
    if (this.texture.gamma === false) {
      this.gamma = 0;
    } else {
      this.gamma = 1;
    }
    if (this.texture.affine) {
      this.mul = this.texture.affine[0];
      this.add = this.texture.affine[1];
    } else {
      this.mul = 1;
      this.add = 0;
    }
  }

  Window.prototype.draw = function(xscale, yscale, one2one, cx, cy, active) {
    var h, height, max, s, w, width;
    width = this.texture.tex.width;
    height = this.texture.tex.height;
    max = Math.max(width, height);
    w = width / max;
    h = height / max;
    s = 1 / Math.max(w * xscale, h * yscale);
    w = w * (1 - one2one) + s * w * one2one;
    h = h * (1 - one2one) + s * h * one2one;
    return this.node.sampler('source', this.texture.tex).f('mixgamma', this.gamma).f('diva', this.diva).f('border_factor', active).val2('affine', this.mul, this.add).val2('size', w * xscale, h * yscale).val2('offset', (this.x - cx) * xscale, (this.y - cy) * yscale).draw();
  };

  return Window;

})();

return Windows = (function() {

  function Windows(gl, gui, textures) {
    var active, folder, gridsize, i, labels, maxx, maxy, minx, miny, texture, window, x, y, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    this.gl = gl;
    this.textures = textures;
    this.prev = __bind(this.prev, this);

    this.next = __bind(this.next, this);

    this.guiLabelChange = __bind(this.guiLabelChange, this);

    this.labelVisibilityChange = __bind(this.labelVisibilityChange, this);

    gui.remember(this);
    this.label = $('<div id="windowlabel">test</div>').appendTo('#ui').hide();
    this.show_all = false;
    this.show_label = false;
    this.needs_clear = $.browser.mozilla;
    this.node = new Rendernode(this.gl, {
      front: true,
      program: get('window.shader'),
      drawable: quad
    });
    this.windows = [];
    this.labelmap = {};
    labels = [];
    gridsize = Math.ceil(Math.sqrt(this.textures.length));
    _ref = this.textures;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      texture = _ref[i];
      x = i % gridsize;
      y = gridsize - Math.floor(i / gridsize) - 1;
      window = new Window(i, texture, this.node, x * 2.2, y * 2.2);
      this.labelmap[window.label] = window;
      this.windows.push(window);
      labels.push(window.label);
    }
    minx = null;
    maxx = null;
    miny = null;
    maxy = null;
    _ref1 = this.windows;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      window = _ref1[_j];
      minx = minx !== null ? Math.min(window.x, minx) : window.x;
      maxx = maxx !== null ? Math.max(window.x, maxx) : window.x;
      miny = miny !== null ? Math.min(window.y, miny) : window.y;
      maxy = maxy !== null ? Math.max(window.y, maxy) : window.y;
    }
    this.cx = (minx + maxx) / 2;
    this.cy = (miny + maxy) / 2;
    this.full_scale = 1.9 / Math.min(maxx - minx + 2, maxy - miny + 2);
    this.zoom = 0.0;
    this.active = this.windows.length - 1;
    keys.press('right', this.next);
    keys.press('left', this.prev);
    keys.press('down', function() {
      var new_value;
      new_value = _this.active + gridsize;
      if (new_value < _this.windows.length) {
        _this.active = new_value;
      } else {
        _this.active = _this.active % gridsize;
      }
      return _this.setActive();
    });
    keys.press('up', function() {
      var new_value;
      new_value = _this.active - gridsize;
      if (new_value >= 0) {
        _this.active = new_value;
      } else {
        new_value = gridsize * gridsize + new_value;
        while (new_value >= _this.windows.length) {
          new_value -= gridsize;
        }
        _this.active = new_value;
      }
      return _this.setActive();
    });
    keys.press('space', function() {
      _this.show_all = !_this.show_all;
      return _this.all_ctrl.setValue(_this.show_all);
    });
    keys.press('enter', function() {
      _this.show_all = !_this.show_all;
      return _this.all_ctrl.setValue(_this.show_all);
    });
    active = this.getActive();
    this.x = active.x;
    this.y = active.y;
    folder = gui.addFolder('Views');
    this.all_ctrl = folder.add(this, 'show_all').name('Overview');
    folder.add(this, 'next').name('Next view');
    folder.add(this, 'prev').name('Prev view');
    this.window_label = active.label;
    this.guiLabel = folder.add(this, 'window_label', labels).name('View').onChange(this.guiLabelChange);
    folder.add(this, 'show_label').name('Labels').onChange(this.labelVisibilityChange);
    this.guiLabelChange();
  }

  Windows.prototype.labelVisibilityChange = function() {
    if (this.show_label) {
      return this.label.clearQueue().fadeIn();
    } else {
      return this.label.clearQueue().fadeOut();
    }
  };

  Windows.prototype.guiLabelChange = function() {
    var window;
    window = this.labelmap[this.window_label];
    this.active = window.index;
    return this.setActive();
  };

  Windows.prototype.getActive = function() {
    return this.windows[this.active];
  };

  Windows.prototype.setActive = function() {
    var text;
    text = this.getActive().label;
    this.window_label = text;
    this.guiLabel.updateDisplay();
    return this.label.text(text);
  };

  Windows.prototype.next = function() {
    this.active = (this.active + 1) % this.windows.length;
    return this.setActive();
  };

  Windows.prototype.prev = function() {
    if (this.active === 0) {
      this.active = this.windows.length - 1;
    } else {
      this.active -= 1;
    }
    return this.setActive();
  };

  Windows.prototype.step = function() {
    var active, tx, ty;
    active = this.getActive();
    tx = active.x;
    ty = active.y;
    this.x = this.x + (tx - this.x) * 0.1;
    this.y = this.y + (ty - this.y) * 0.1;
    if (this.show_all) {
      return this.zoom = this.zoom + (1 - this.zoom) * 0.1;
    } else {
      return this.zoom = this.zoom + (0 - this.zoom) * 0.1;
    }
  };

  Windows.prototype.draw = function(gamma) {
    var active, factor, height, width, window, xscale, yscale, _i, _len, _ref;
    this.step();
    if (this.needs_clear === true) {
      this.gl.clearColor(0, 0, 0, 0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }
    this.node.start().f('gamma', gamma);
    width = this.node.width;
    height = this.node.height;
    if (width > height) {
      xscale = height / width;
      yscale = 1;
    } else {
      xscale = 1;
      yscale = width / height;
    }
    factor = 1.0 - this.zoom + this.zoom * this.full_scale;
    xscale *= factor;
    yscale *= factor;
    active = this.getActive();
    _ref = this.windows;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      window = _ref[_i];
      if (window !== active) {
        this.drawWindow(xscale, yscale, window, 0);
      }
    }
    this.drawWindow(xscale, yscale, active, 1);
    return this.node.end();
  };

  Windows.prototype.drawWindow = function(xscale, yscale, window, active) {
    var dx, dy, l, one2one, x, y;
    dx = window.x - this.x;
    dy = window.y - this.y;
    l = Math.sqrt(dx * dx + dy * dy);
    if (l > 0) {
      one2one = Math.min(1 / (l * 2), 1);
    } else {
      one2one = 1;
    }
    x = this.x * (1 - this.zoom) + this.cx * this.zoom;
    y = this.y * (1 - this.zoom) + this.cy * this.zoom;
    active = Math.pow(one2one, 2.0) * this.zoom;
    return window.draw(xscale, yscale, one2one * (1 - this.zoom), x, y, active);
  };

  return Windows;

})();
