// Generated by CoffeeScript 1.3.3
var Cubemap, Depthbuffer, Framebuffer, Quad, Rendernode, State, Texture2D, default_state, _ref, _ref1;

_ref = require('webgl/framebuffer'), Framebuffer = _ref.Framebuffer, Depthbuffer = _ref.Depthbuffer;

_ref1 = require('webgl/texture'), Texture2D = _ref1.Texture2D, Cubemap = _ref1.Cubemap;

Quad = require('webgl/quad');

State = (function() {

  function State(gl) {
    this.gl = gl;
    this.depthTest = false;
    this.depthWrite = false;
    this.cullFace = null;
    this.alphaToCoverage = false;
    this.blend = false;
  }

  State.prototype.setDefaults = function() {
    this.gl.disable(this.gl.DEPTH_TEST);
    this.gl.depthMask(false);
    this.gl.cullFace(this.gl.BACK);
    this.gl.disable(this.gl.CULL_FACE);
    this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    this.gl.disable(this.gl.BLEND);
    return this;
  };

  State.prototype.set = function() {
    var mode;
    if (this.depthTest) {
      this.gl.enable(this.gl.DEPTH_TEST);
      mode = this.gl[this.depthTest];
      if (mode) {
        this.gl.depthFunc(mode);
      } else {
        this.gl.depthFunc(this.gl.LEQUAL);
      }
    }
    if (this.depthWrite) {
      this.gl.depthMask(true);
    }
    if (this.cullFace) {
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.cullFace(this.gl[this.cullFace]);
    }
    if (this.blend) {
      this.gl.enable(this.gl.BLEND);
      if (this.blend === 'additive') {
        this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
      }
    }
    if (this.alphaToCoverage) {
      this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
    return this;
  };

  State.prototype.revert = function() {
    if (this.depthTest) {
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LESS);
    }
    if (this.depthWrite) {
      this.gl.depthMask(false);
    }
    if (this.cullFace) {
      this.gl.disable(this.gl.CULL_FACE);
    }
    if (this.blend) {
      this.gl.disable(this.gl.BLEND);
    }
    if (this.alphaToCoverage) {
      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
    return this;
  };

  return State;

})();

default_state = null;

return Rendernode = (function() {

  Rendernode.stateDefaults = function(gl) {
    return default_state = new State(gl).setDefaults();
  };

  function Rendernode(gl, _arg) {
    var blend, cullFace, depthTest, depthWrite, _ref2, _ref3;
    this.gl = gl;
    this.width = _arg.width, this.height = _arg.height, this.program = _arg.program, this.drawable = _arg.drawable, this.type = _arg.type, this.front = _arg.front, depthTest = _arg.depthTest, depthWrite = _arg.depthWrite, cullFace = _arg.cullFace, this.depthBuffer = _arg.depthBuffer, blend = _arg.blend, this.filter = _arg.filter, this.channels = _arg.channels, this.format = _arg.format, this.hdrClear = _arg.hdrClear;
    this.xoff = 0;
    this.yoff = 0;
    this.state = new State(this.gl);
    this.texunit_counter = 0;
    this.texunits = {};
    if ((_ref2 = this.type) == null) {
      this.type = this.gl.UNSIGNED_BYTE;
    }
    if ((_ref3 = this.front) == null) {
      this.front = false;
    }
    if (depthTest == null) {
      depthTest = false;
    }
    this.depthTest(depthTest);
    if (depthWrite == null) {
      depthWrite = false;
    }
    this.depthWrite(depthWrite);
    if (cullFace == null) {
      cullFace = null;
    }
    this.cullFace(cullFace);
    if (blend == null) {
      blend = false;
    }
    this.state.blend = blend;
    if (!this.front) {
      this.createBuffers();
    }
    if (this.hdrClear) {
      this.clearShader = get('hdr_clear.shader');
    }
  }

  Rendernode.prototype.createBuffers = function() {
    this.output = new Texture2D(this.gl, {
      channels: this.channels,
      format: this.format,
      type: this.type
    }).bind().clampToEdge();
    if (this.filter === 'nearest') {
      this.output.nearest();
    } else {
      this.output.linear();
    }
    if (this.width && this.height) {
      this.output.setSize(this.width, this.height);
    } else {
      this.output.setSize(16, 16);
    }
    this.output.unbind();
    this.fbo = new Framebuffer(this.gl).bind().color(this.output).unbind();
    if (this.depthBuffer) {
      return this.addDepth();
    }
  };

  Rendernode.prototype.addDepth = function(buffer) {
    if (buffer == null) {
      buffer = this.depthBuffer;
    }
    if (!this.depth && !this.front) {
      if (buffer instanceof Depthbuffer) {
        this.depth = buffer;
      } else {
        this.depth = new Depthbuffer(this.gl).setSize(this.output.width, this.output.height);
      }
      this.fbo.bind().depth(this.depth).unbind();
    }
    return this;
  };

  Rendernode.prototype.cullFace = function(side) {
    if (side == null) {
      side = null;
    }
    this.state.cullFace = side;
    return this;
  };

  Rendernode.prototype.depthWrite = function(enabled) {
    if (enabled == null) {
      enabled = false;
    }
    this.state.depthWrite = enabled;
    return this;
  };

  Rendernode.prototype.depthTest = function(enabled) {
    if (enabled == null) {
      enabled = false;
    }
    this.state.depthTest = enabled;
    return this;
  };

  Rendernode.prototype.alphaToCoverage = function(enabled) {
    if (enabled == null) {
      enabled = false;
    }
    this.state.alphaToCoverage = enabled;
    return this;
  };

  Rendernode.prototype.blendAdditive = function() {
    this.state.blend = 'additive';
    return this;
  };

  Rendernode.prototype.filterNearest = function() {
    this.output.bind().nearest().unbind();
    return this;
  };

  Rendernode.prototype.start = function() {
    this.started = true;
    this.viewport();
    this.state.set();
    if (this.program) {
      this.program.use();
    }
    if (!this.front) {
      this.fbo.bind();
    }
    if (this.drawable) {
      this.setPointers(this.drawable);
    }
    return this;
  };

  Rendernode.prototype.setPointers = function(drawable) {
    if (drawable !== this.current_drawable) {
      this.current_drawable = drawable;
      return drawable.setPointersForShader(this.program);
    }
  };

  Rendernode.prototype.end = function() {
    this.started = false;
    this.current_drawable = null;
    this.state.revert();
    if (!this.front) {
      this.fbo.unbind();
    }
    return this;
  };

  Rendernode.prototype.sampler = function(name, source) {
    var texture, unit;
    if (source.output) {
      texture = source.output;
    } else {
      texture = source;
    }
    unit = this.texunits[name];
    if (unit === void 0) {
      unit = this.texunits[name] = this.texunit_counter++;
    }
    texture.bind(unit);
    this.program.i(name, unit);
    return this;
  };

  Rendernode.prototype.mat4 = function(name, value) {
    this.program.mat4(name, value);
    return this;
  };

  Rendernode.prototype.mat3 = function(name, value) {
    this.program.mat3(name, value);
    return this;
  };

  Rendernode.prototype.val3 = function(name, x, y, z) {
    this.program.val3(name, x, y, z);
    return this;
  };

  Rendernode.prototype.vec3 = function(name, value) {
    this.program.vec3(name, value);
    return this;
  };

  Rendernode.prototype.f = function(name, value) {
    this.program.f(name, value);
    return this;
  };

  Rendernode.prototype.fv = function(name, values) {
    this.program.fv(name, values);
    return this;
  };

  Rendernode.prototype.val2 = function(name, x, y) {
    this.program.val2(name, x, y);
    return this;
  };

  Rendernode.prototype.clear = function(r, g, b, a) {
    if (r == null) {
      r = 0;
    }
    if (g == null) {
      g = 0;
    }
    if (b == null) {
      b = 0;
    }
    if (a == null) {
      a = 1;
    }
    if (this.hdrClear) {
      if (!this.front) {
        this.fbo.bind();
      }
      this.clearShader.use().val4('clear_color', r, g, b, a).draw(quad);
    } else {
      this.gl.clearColor(r, g, b, a);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    }
    return this;
  };

  Rendernode.prototype.clearBoth = function(r, g, b, a, depth) {
    if (r == null) {
      r = 0;
    }
    if (g == null) {
      g = 0;
    }
    if (b == null) {
      b = 0;
    }
    if (a == null) {
      a = 1;
    }
    if (depth == null) {
      depth = 1;
    }
    this.gl.clearColor(r, g, b, a);
    this.gl.clearDepth(depth);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    return this;
  };

  Rendernode.prototype.clearDepth = function(depth) {
    if (depth == null) {
      depth = 1;
    }
    this.gl.clearDepth(depth);
    this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
    return this;
  };

  Rendernode.prototype.draw = function(drawable) {
    var do_end;
    if (drawable == null) {
      drawable = this.drawable;
    }
    do_end = false;
    if (!this.started) {
      do_end = true;
      this.start();
    }
    this.program.val2('viewport', this.width, this.height);
    if (drawable !== this.current_drawable) {
      this.setPointers(drawable);
    }
    drawable.draw();
    if (do_end) {
      this.end();
    }
    return this;
  };

  Rendernode.prototype.drawModel = function(texture_type, sampler_name) {
    var c, material, _i, _len, _ref2;
    if (sampler_name == null) {
      sampler_name = texture_type;
    }
    if (texture_type) {
      _ref2 = this.drawable.materials[texture_type];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        material = _ref2[_i];
        this.f('specularity', material.specularity);
        c = material.diffuse_color;
        this.val3('diffuse_color', c.r, c.g, c.b);
        this.sampler(sampler_name, material[texture_type]);
        this.drawable.drawRange(material.start, material.size);
      }
    } else {
      this.draw();
    }
    return this;
  };

  Rendernode.prototype.resize = function(width, height) {
    this.width = Math.floor(width);
    this.height = Math.floor(height);
    if (this.output) {
      this.output.bind().setSize(this.width, this.height).unbind();
    }
    if (this.depth) {
      this.depth.setSize(this.width, this.height);
    }
    if (this.fbo) {
      return this.fbo.bind().check().unbind();
    }
  };

  Rendernode.prototype.viewport = function(x, y, width, height) {
    if (x == null) {
      x = this.xoff;
    }
    if (y == null) {
      y = this.yoff;
    }
    if (width == null) {
      width = this.width;
    }
    if (height == null) {
      height = this.height;
    }
    if (width && height) {
      this.xoff = x;
      this.yoff = y;
      this.width = width;
      this.height = height;
      if (this.started) {
        this.gl.viewport(x, y, width, height);
      }
      return this;
    }
  };

  Rendernode.prototype.bind = function(unit) {
    if (unit == null) {
      unit = 0;
    }
    return this.output.bind(unit);
  };

  return Rendernode;

})();
