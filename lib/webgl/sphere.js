// Generated by CoffeeScript 1.3.3
var Sphere, faces, icosahedron, midp, normalize, phi, subdivide, v1, v10, v11, v12, v2, v3, v4, v5, v6, v7, v8, v9, vertexlist,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

phi = (1 + Math.sqrt(5)) / 2;

midp = function(v1, v2) {
  var x1, x2, x3, y1, y2, y3, z1, z2, z3;
  x1 = v1[0];
  y1 = v1[1];
  z1 = v1[2];
  x2 = v2[0];
  y2 = v2[1];
  z2 = v2[2];
  x3 = (x1 + x2) / 2;
  y3 = (y1 + y2) / 2;
  z3 = (z1 + z2) / 2;
  return [x3, y3, z3];
};

normalize = function(faces, r) {
  var face, l, new_face, result, vertex, x, y, z, _i, _j, _len, _len1;
  if (r == null) {
    r = 1;
  }
  result = [];
  for (_i = 0, _len = faces.length; _i < _len; _i++) {
    face = faces[_i];
    new_face = [];
    result.push(new_face);
    for (_j = 0, _len1 = face.length; _j < _len1; _j++) {
      vertex = face[_j];
      x = vertex[0];
      y = vertex[1];
      z = vertex[2];
      l = Math.sqrt(x * x + y * y + z * z);
      new_face.push([(r * x) / l, (r * y) / l, (r * z) / l]);
    }
  }
  return result;
};

subdivide = function(faces) {
  var face, result, v0, v1, v2, va, vb, vc, _i, _len;
  result = [];
  for (_i = 0, _len = faces.length; _i < _len; _i++) {
    face = faces[_i];
    v0 = face[0];
    v1 = face[1];
    v2 = face[2];
    va = midp(v0, v1);
    vb = midp(v1, v2);
    vc = midp(v2, v0);
    result.push([v0, va, vc], [va, v1, vb], [vc, vb, v2], [va, vb, vc]);
  }
  return result;
};

v1 = [1, phi, 0];

v2 = [-1, phi, 0];

v3 = [0, 1, phi];

v4 = [0, 1, -phi];

v5 = [phi, 0, 1];

v6 = [-phi, 0, 1];

v7 = [-phi, 0, -1];

v8 = [phi, 0, -1];

v9 = [0, -1, phi];

v10 = [0, -1, -phi];

v11 = [-1, -phi, 0];

v12 = [1, -phi, 0];

faces = [[v1, v2, v3], [v2, v1, v4], [v1, v3, v5], [v2, v6, v3], [v2, v7, v6], [v2, v4, v7], [v1, v5, v8], [v1, v8, v4], [v9, v3, v6], [v3, v9, v5], [v4, v10, v7], [v4, v8, v10], [v6, v7, v11], [v6, v11, v9], [v7, v10, v11], [v5, v12, v8], [v12, v5, v9], [v12, v10, v8], [v11, v12, v9], [v12, v11, v10]];

icosahedron = normalize(faces);

vertexlist = function(faces) {
  var face, vertex, vertices, x, y, z, _i, _j, _len, _len1;
  vertices = [];
  for (_i = 0, _len = faces.length; _i < _len; _i++) {
    face = faces[_i];
    for (_j = 0, _len1 = face.length; _j < _len1; _j++) {
      vertex = face[_j];
      x = vertex[0];
      y = vertex[1];
      z = vertex[2];
      vertices.push(x, y, z);
    }
  }
  return vertices;
};

return Sphere = (function(_super) {

  __extends(Sphere, _super);

  Sphere.prototype.attribs = ['position'];

  Sphere.prototype.pointers = [
    {
      name: 'position',
      size: 3,
      offset: 0,
      stride: 3
    }
  ];

  Sphere.makeVertices = function(radius, subdivisions) {
    var i, template, vertices, _i;
    if (radius == null) {
      radius = 1;
    }
    if (subdivisions == null) {
      subdivisions = 3;
    }
    template = icosahedron;
    for (i = _i = 0; 0 <= subdivisions ? _i < subdivisions : _i > subdivisions; i = 0 <= subdivisions ? ++_i : --_i) {
      template = subdivide(template);
      template = normalize(template);
    }
    faces = normalize(template, radius);
    vertices = vertexlist(faces);
    return vertices;
  };

  function Sphere(gl, radius, subdivisions) {
    var vertices;
    this.gl = gl;
    if (radius == null) {
      radius = 1;
    }
    if (subdivisions == null) {
      subdivisions = 3;
    }
    Sphere.__super__.constructor.call(this);
    vertices = Sphere.makeVertices(radius, subdivisions);
    this.size = vertices.length / 3;
    this.uploadList(vertices);
  }

  return Sphere;

})(require('drawable'));
